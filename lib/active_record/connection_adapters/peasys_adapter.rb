# frozen_string_literal: true

require "active_record/connection_adapters/abstract_adapter"
require_relative "peasys/quoting"
require_relative "peasys/database_statements"
require_relative "peasys/schema_statements"
require_relative "peasys/schema_creation"
require_relative "peasys/schema_definitions"
require_relative "peasys/column"
require_relative "peasys/schema_dumper"

require "arel/visitors/peasys"

module ActiveRecord
  module ConnectionAdapters
    class PeasysAdapter < AbstractAdapter
      ADAPTER_NAME = "Peasys"

      include Peasys::Quoting
      include Peasys::DatabaseStatements
      include Peasys::SchemaStatements

      class << self
        def new_client(config)
          PeaClient.new(
            config[:ip_address].to_s,
            config[:partition_name].to_s,
            config[:port].to_i,
            config[:username].to_s,
            config[:password].to_s,
            config[:id_client].to_s,
            config.fetch(:online_version, true),
            config.fetch(:retrieve_statistics, false)
          )
        rescue PeaConnexionError => e
          raise ActiveRecord::ConnectionNotEstablished, e.message
        rescue PeaInvalidCredentialsError => e
          raise ActiveRecord::ConnectionNotEstablished, e.message
        rescue PeaInvalidLicenseKeyError => e
          raise ActiveRecord::ConnectionNotEstablished, e.message
        end
      end

      def initialize(...)
        super

        @connection_parameters = @config
        @config[:schema] ||= @config[:username]&.upcase
      end

      # -- Adapter identification --

      def adapter_name
        ADAPTER_NAME
      end

      # -- Feature flags --

      def supports_migrations?;               true  end
      def supports_primary_key?;              true  end
      def supports_foreign_keys?;             true  end
      def supports_views?;                    true  end
      def supports_datetime_with_precision?;  true  end
      def supports_ddl_transactions?;         false end
      def supports_savepoints?;               false end
      def supports_transaction_isolation?;    false end
      def supports_explain?;                  false end
      def supports_index_sort_order?;         true  end
      def supports_insert_returning?;         false end
      def supports_common_table_expressions?; true  end
      def supports_lazy_transactions?;        true  end
      def supports_check_constraints?;        true  end
      def supports_comments?;                 true  end
      def supports_insert_on_duplicate_skip?; false end
      def supports_insert_on_duplicate_update?; false end

      # -- Schema Dumper --

      def self.database_exists?(config)
        true # Assume the IBM i database always exists if configured
      end

      # -- Connection management --

      def active?
        @raw_connection&.connexion_status == 1
      rescue
        false
      end

      def disconnect!
        super
        @raw_connection&.disconnect
      rescue
        nil
      end

      # -- Type mapping --

      NATIVE_DATABASE_TYPES = {
        primary_key: "INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY",
        string:      { name: "VARCHAR",   limit: 255 },
        text:        { name: "CLOB" },
        integer:     { name: "INTEGER" },
        bigint:      { name: "BIGINT" },
        float:       { name: "DOUBLE" },
        decimal:     { name: "DECIMAL" },
        datetime:    { name: "TIMESTAMP" },
        timestamp:   { name: "TIMESTAMP" },
        time:        { name: "TIME" },
        date:        { name: "DATE" },
        binary:      { name: "BLOB" },
        boolean:     { name: "SMALLINT" },
        json:        { name: "CLOB" },
      }.freeze

      def native_database_types
        NATIVE_DATABASE_TYPES
      end

      class << self
        private

          def initialize_type_map(m)
            super

            # DB2-specific type aliases
            m.alias_type %r(clob)i,       "text"
            m.alias_type %r(dbclob)i,     "text"
            m.alias_type %r(blob)i,       "binary"
            m.alias_type %r(graphic)i,    "string"
            m.alias_type %r(vargraphic)i, "string"
            m.alias_type %r(timestamp)i,  "datetime"
            m.alias_type %r(timestmp)i,   "datetime"
            m.alias_type %r(double)i,     "float"
            m.alias_type %r(real)i,       "float"
            m.alias_type %r(numeric)i,    "decimal"
            m.alias_type %r(decfloat)i,   "decimal"

            m.register_type %r(smallint)i, Type::Integer.new(limit: 2)
            m.register_type %r(\Ainteger\z)i, Type::Integer.new(limit: 4)
            m.register_type %r(bigint)i, Type::Integer.new(limit: 8)
          end
      end

      TYPE_MAP = Type::TypeMap.new.tap { |m| initialize_type_map(m) }

      private

        def type_map
          TYPE_MAP
        end

        def connect
          @raw_connection = self.class.new_client(@connection_parameters)
        rescue PeaConnexionError => e
          raise ConnectionNotEstablished, e.message
        end

        def reconnect
          @raw_connection&.disconnect rescue nil
          connect
        end

        def arel_visitor
          Arel::Visitors::Peasys.new(self)
        end

        def configure_connection
          if @config[:schema]
            with_raw_connection do |conn|
              conn.execute_sql("SET SCHEMA #{@config[:schema].upcase}")
            end
          end
        end

        def translate_exception(exception, message:, sql:, binds:)
          case exception
          when PeaQueryerror
            msg = exception.message
            if msg =~ /SQL0803|23505/      # Unique constraint violation
              RecordNotUnique.new(message, sql: sql, binds: binds, connection_pool: @pool)
            elsif msg =~ /SQL0530|SQL0532|23503/ # FK violation
              InvalidForeignKey.new(message, sql: sql, binds: binds, connection_pool: @pool)
            elsif msg =~ /SQL0407|23502/    # NOT NULL violation
              NotNullViolation.new(message, sql: sql, binds: binds, connection_pool: @pool)
            elsif msg =~ /SQL0433/          # Value too long
              ValueTooLong.new(message, sql: sql, binds: binds, connection_pool: @pool)
            else
              StatementInvalid.new(message, sql: sql, binds: binds, connection_pool: @pool)
            end
          when PeaConnexionError
            ConnectionNotEstablished.new(message, connection_pool: @pool)
          else
            super
          end
        end
    end
  end
end

# Rails 7.2 adapter registration
ActiveRecord::ConnectionAdapters.register(
  "peasys",
  "ActiveRecord::ConnectionAdapters::PeasysAdapter",
  "active_record/connection_adapters/peasys_adapter"
)
